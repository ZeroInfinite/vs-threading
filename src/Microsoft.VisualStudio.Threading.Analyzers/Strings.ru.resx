<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AwaitXInstead" xml:space="preserve">
    <value>Вместо этого используйте Await {0}.</value>
    <comment>"await" is a C# keyword and should not be translated.
{0} is a method name.</comment>
  </data>
  <data name="UseAwaitInstead" xml:space="preserve">
    <value>Вместо этого используйте await.</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_MessageFormat" xml:space="preserve">
    <value>Синхронное ожидание задач или объектов awaiter может вызвать взаимоблокировки. Вместо этого используйте метод JoinableTaskFactory.Run.</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_Title" xml:space="preserve">
    <value>Избегание проблемных синхронных ожиданий</value>
  </data>
  <data name="VSTHRD010_MessageFormat" xml:space="preserve">
    <value>Службу Visual Studio "{0}" следует явно использовать в основном потоке.
Сначала вызовите ThreadHelper.ThrowIfNotOnUIThread() или используйте await в JoinableTaskFactory.SwitchToMainThreadAsync().</value>
  </data>
  <data name="VSTHRD010_Title" xml:space="preserve">
    <value>Использование служб VS в потоке пользовательского интерфейса</value>
  </data>
  <data name="VSTHRD100_MessageFormat" xml:space="preserve">
    <value>Избегайте методов "async void", так как любые исключения, не обработанные этим методом, вызовут сбой процесса.</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD100_Title" xml:space="preserve">
    <value>Избегание методов async void</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD101_MessageFormat" xml:space="preserve">
    <value>Не используйте лямбда-выражения async в типах делегатов, которые возвращают void, так как исключения, не обработанные делегатом, вызовут сбой процесса.</value>
    <comment>"void" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD101_Title" xml:space="preserve">
    <value>Избегание неподдерживаемых делегатов async</value>
  </data>
  <data name="VSTHRD106_MessageFormat" xml:space="preserve">
    <value>Делегаты AsyncEventHandler следует вызывать при помощи метода расширения "TplExtensions.InvokeAsync()", определенного в сборке Microsoft.VisualStudio.Threading.</value>
  </data>
  <data name="VSTHRD106_Title" xml:space="preserve">
    <value>Использование InvokeAsync для вызова асинхронных событий</value>
  </data>
  <data name="VSTHRD003_MessageFormat" xml:space="preserve">
    <value>При вызове await в объекте Task в JoinableTaskFactory.Run (и при условии, что задача инициализирована за пределами делегата) могут произойти взаимоблокировки.
Вы можете избежать этой проблемы, инициализировав задачу в делегате или использовав JoinableTask вместо Task.</value>
  </data>
  <data name="VSTHRD003_Title" xml:space="preserve">
    <value>Избегание await в неприсоединяемых задачах в контекстах соединения</value>
  </data>
  <data name="VSTHRD011_MessageFormat" xml:space="preserve">
    <value>Lazy&lt;Task&lt;T&gt;&gt;.Value может вызвать взаимоблокировку.
Вместо этого используйте AsyncLazy&lt;T&gt;.</value>
  </data>
  <data name="VSTHRD011_Title" xml:space="preserve">
    <value>Не используйте Lazy&lt;T&gt;, где T — объект Task&lt;T2&gt;</value>
  </data>
  <data name="VSTHRD103_MessageFormat" xml:space="preserve">
    <value>{0} синхронно блокирует. Вместо этого используйте Await {1}.</value>
  </data>
  <data name="VSTHRD103_MessageFormat_UseAwaitInstead" xml:space="preserve">
    <value>{0} синхронно блокирует. Вместо этого используйте await.</value>
  </data>
  <data name="VSTHRD103_Title" xml:space="preserve">
    <value>Вызов асинхронных методов в методе async</value>
  </data>
  <data name="VSTHRD102_MessageFormat" xml:space="preserve">
    <value>Разрешите использовать вызовы методов синхронной блокировки, такие как JoinableTaskFactory.Run или Task.Result, только элементам общедоступных точек входа, где требуется синхронизация. Если их будут использовать внутренние элементы, между асинхронными фреймами могут быть добавлены лишние синхронные фреймы, что приведет к нехватке ресурсов в пуле потока.</value>
  </data>
  <data name="VSTHRD102_Title" xml:space="preserve">
    <value>Реализация внутренней логики асинхронно</value>
  </data>
  <data name="VSTHRD200_CodeFix_Title" xml:space="preserve">
    <value>Переименование в {0}</value>
    <comment>{0} is a method name.</comment>
  </data>
  <data name="VSTHRD200_MessageFormat" xml:space="preserve">
    <value>Используйте суффикс "Async" в названиях методов, возвращающих Task.</value>
  </data>
  <data name="VSTHRD200_Title" xml:space="preserve">
    <value>Использование суффикса "Async" в асинхронных методах</value>
  </data>
  <data name="VSTHRD100_CodeFix_Title" xml:space="preserve">
    <value>Изменение типа возвращаемого значения на Task</value>
    <comment>Task is a type name and should not be translated.</comment>
  </data>
  <data name="VSTHRD105_MessageFormat" xml:space="preserve">
    <value>Избегайте перегрузок методов, предполагающих TaskScheduler.Current. Используйте перегрузку, которая допускает TaskScheduler, и явно укажите свойство TaskScheduler.Default (или любое другое).</value>
  </data>
  <data name="VSTHRD105_Title" xml:space="preserve">
    <value>Избегание перегрузок методов, предполагающих TaskScheduler.Current</value>
  </data>
  <data name="VSTHRD012_MessageFormat" xml:space="preserve">
    <value>Укажите экземпляр JoinableTaskFactory в этом вызове (или другой перегрузке), чтобы избежать взаимоблокировки с основным потоком.</value>
  </data>
  <data name="VSTHRD012_Title" xml:space="preserve">
    <value>Указывайте JoinableTaskFactory, где это возможно</value>
  </data>
  <data name="VSTHRD104_MessageFormat" xml:space="preserve">
    <value>Предоставьте асинхронную версию этого метода, которая не использует синхронную блокировку. Затем упростите этот метод, вызывая асинхронную версию внутри делегата JoinableTaskFactory.Run.</value>
  </data>
  <data name="VSTHRD104_Title" xml:space="preserve">
    <value>Предоставляйте асинхронные методы</value>
  </data>
  <data name="VSTHRD001_MessageFormat" xml:space="preserve">
    <value>Дождитесь, когда JoinableTaskFactory.SwitchToMainThreadAsync() переключится на поток пользовательского интерфейса, и не используйте API, которые могут вызывать взаимоблокировки или требуют указания приоритета.</value>
  </data>
  <data name="VSTHRD001_Title" xml:space="preserve">
    <value>Избегайте использования устаревших API переключения потоков</value>
    <comment>thread switching APIs refers to Visual Studio SDK or .NET methods that can be used to switch threads, but are obsolete and should be avoided.</comment>
  </data>
  <data name="VSTHRD107_MessageFormat" xml:space="preserve">
    <value>Отсутствует оператор await для выражения "using".</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD107_Title" xml:space="preserve">
    <value>Задача await в выражении "using"</value>
    <comment>"await Task" is a C# compound term, and "using" is a C# keyword. These should not be translated.</comment>
  </data>
  <data name="VSTHRD107_CodeFix_Title" xml:space="preserve">
    <value>Выражение "using" в await</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
</root>