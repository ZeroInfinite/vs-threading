<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AwaitXInstead" xml:space="preserve">
    <value>Use await {0} en su lugar</value>
    <comment>"await" is a C# keyword and should not be translated.
{0} is a method name.</comment>
  </data>
  <data name="UseAwaitInstead" xml:space="preserve">
    <value>Use await en su lugar</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_MessageFormat" xml:space="preserve">
    <value>La espera sincrónica de tareas o elementos que ejecutan await puede provocar interbloqueos. Use JoinableTaskFactory.Run en su lugar.</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_Title" xml:space="preserve">
    <value>Evite esperas sincrónicas problemáticas</value>
  </data>
  <data name="VSTHRD010_MessageFormat" xml:space="preserve">
    <value>El servicio "{0}" de Visual Studio debe usarse explícitamente en el subproceso principal. 
Llame a ThreadHelper.ThrowIfNotOnUIThread() o el elemento await JoinableTaskFactory.SwitchToMainThreadAsync() en primer lugar.</value>
  </data>
  <data name="VSTHRD010_Title" xml:space="preserve">
    <value>Use servicios de VS desde el subproceso de IU</value>
  </data>
  <data name="VSTHRD100_MessageFormat" xml:space="preserve">
    <value>Evite métodos "async void", porque las excepciones no controladas por el método bloquearán el proceso.</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD100_Title" xml:space="preserve">
    <value>Evite métodos async void</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD101_MessageFormat" xml:space="preserve">
    <value>Evite usar la lambda async para un tipo de delegado de devolución void, porque las excepciones no controladas por el delegado bloquearán el proceso.</value>
    <comment>"void" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD101_Title" xml:space="preserve">
    <value>Evite delegados asincrónicos no compatibles</value>
  </data>
  <data name="VSTHRD106_MessageFormat" xml:space="preserve">
    <value>Los delegados de AsyncEventHandler deben invocarse a través del método de extensión "TplExtensions.InvokeAsync()" definido en el ensamblado Microsoft.VisualStudio.Threading.</value>
  </data>
  <data name="VSTHRD106_Title" xml:space="preserve">
    <value>Use InvokeAsync para desencadenar eventos asincrónicos</value>
  </data>
  <data name="VSTHRD003_MessageFormat" xml:space="preserve">
    <value>La llamada a await en un elemento Task dentro de JoinableTaskFactory.Run, cuando la tarea se ha iniciado fuera del delegado, puede provocar posibles interbloqueos.
Puede evitar este problema asegurándose de que la tarea se ha iniciado dentro del delegado o usando JoinableTask en lugar de Task.</value>
  </data>
  <data name="VSTHRD003_Title" xml:space="preserve">
    <value>Evite usar await para tareas que no sean de unión en contextos de unión</value>
  </data>
  <data name="VSTHRD011_MessageFormat" xml:space="preserve">
    <value>Lazy&lt;Task&lt;T&gt;&gt;.Value puede provocar interbloqueos.
Use AsyncLazy&lt;T&gt; en su lugar.</value>
  </data>
  <data name="VSTHRD011_Title" xml:space="preserve">
    <value>Evite el uso de Lazy&lt;T&gt; donde T es Task&lt;T2&gt;</value>
  </data>
  <data name="VSTHRD103_MessageFormat" xml:space="preserve">
    <value>{0} bloquea sincrónicamente. Use await {1} en su lugar.</value>
  </data>
  <data name="VSTHRD103_MessageFormat_UseAwaitInstead" xml:space="preserve">
    <value>{0} bloquea sincrónicamente. Use await en su lugar.</value>
  </data>
  <data name="VSTHRD103_Title" xml:space="preserve">
    <value>Llame a métodos asincrónicos cuando esté en un método asincrónico</value>
  </data>
  <data name="VSTHRD102_MessageFormat" xml:space="preserve">
    <value>Limite el uso de llamadas de métodos de bloqueo sincrónico, como JoinableTaskFactory.Run o Task.Result, a miembros de punto de entrada públicos donde tiene que ser sincrónico. El uso para miembros internos puede agregar innecesariamente marcos sincrónicos entre marcos asincrónicos, provocando el agotamiento del conjunto de subprocesos.</value>
  </data>
  <data name="VSTHRD102_Title" xml:space="preserve">
    <value>Implemente la lógica interna asincrónicamente</value>
  </data>
  <data name="VSTHRD200_CodeFix_Title" xml:space="preserve">
    <value>Cambie el nombre a {0}</value>
    <comment>{0} is a method name.</comment>
  </data>
  <data name="VSTHRD200_MessageFormat" xml:space="preserve">
    <value>Use el sufijo "Async" en nombres de métodos de devolución de elementos Task</value>
  </data>
  <data name="VSTHRD200_Title" xml:space="preserve">
    <value>Use el sufijo "Async" para métodos asincrónicos</value>
  </data>
  <data name="VSTHRD105_MessageFormat" xml:space="preserve">
    <value>Evite las sobrecargas de métodos que asumen TaskScheduler.Current. Use una sobrecarga que acepte un elemento TaskScheduler y especifique TaskScheduler.Default (o cualquier otro) explícitamente.</value>
  </data>
  <data name="VSTHRD105_Title" xml:space="preserve">
    <value>Evite las sobrecargas de métodos que asumen TaskScheduler.Current</value>
  </data>
  <data name="VSTHRD100_CodeFix_Title" xml:space="preserve">
    <value>Cambie el tipo de valor devuelto a Task</value>
    <comment>Task is a type name and should not be translated.</comment>
  </data>
  <data name="VSTHRD012_MessageFormat" xml:space="preserve">
    <value>Proporcione una instancia de JoinableTaskFactory en esta llamada (u otra sobrecarga) para evitar interbloqueos con el subproceso principal.</value>
  </data>
  <data name="VSTHRD012_Title" xml:space="preserve">
    <value>Proporcione JoinableTaskFactory donde se permita</value>
  </data>
  <data name="VSTHRD104_MessageFormat" xml:space="preserve">
    <value>Exponga una versión asincrónica de este método que no cause bloqueo de manera sincrónica. A continuación, simplifique este método para llamar a ese método asincrónico dentro de un delegado JoinableTaskFactory.Run.</value>
  </data>
  <data name="VSTHRD104_Title" xml:space="preserve">
    <value>Ofrezca métodos asincrónicos</value>
  </data>
  <data name="VSTHRD001_MessageFormat" xml:space="preserve">
    <value>Use el método await JoinableTaskFactory.SwitchToMainThreadAsync() para cambiar al subproceso de interfaz de usuario en lugar de a API que pueden causar interbloqueo o requerir que se especifique una prioridad.</value>
  </data>
  <data name="VSTHRD001_Title" xml:space="preserve">
    <value>Evite cambiar a API de subprocesos heredados</value>
    <comment>thread switching APIs refers to Visual Studio SDK or .NET methods that can be used to switch threads, but are obsolete and should be avoided.</comment>
  </data>
  <data name="VSTHRD107_MessageFormat" xml:space="preserve">
    <value>Falta el operador await en la expresión "using".</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD107_Title" xml:space="preserve">
    <value>Usar await para tarea dentro de expresión using</value>
    <comment>"await Task" is a C# compound term, and "using" is a C# keyword. These should not be translated.</comment>
  </data>
  <data name="VSTHRD107_CodeFix_Title" xml:space="preserve">
    <value>Usar await en expresión using</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
</root>